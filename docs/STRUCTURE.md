## Structural refactor: columns, tributaries, and loads (Phase A)

This document captures the recent structural refactor, the rationale behind each change, the assumptions we made (and plan to remove later), and the next-phase plan.

### What changed

1) Authoritative column generator
- New: `src/structure/column_generator.py`
- Columns are placed on Y-lines aligned to 18' stall boundaries, 25' aisle boundaries, and ramp centerlines. Along each Y-line, X positions are generated by midpoint spacing with a max span of 31'.
- Columns on ramp centerlines are limited to the ramp section between turn zones.
- Columns inside core rectangles (utility, storage, stairs, elevator) are omitted (cores act as supports).
- West-perimeter columns do not occur inside the entry opening region.

2) Footings now iterate over actual columns
- Existing uniform grid loops were replaced by a pass over `garage.columns`; column classification inferred from Y-line type.
- Tributary area per column is used (when available) to compute column loads for footing design.

3) Semi-full tributary calculator (aggregate)
- New: `src/loads/tributary.py` computes per-column tributary rectangles by midpoints in X and Y.
- Clipping: subtracts core rectangles; subtracts entry opening for west-perimeter lines; clamps ramp-center X to ramp section.
- Loads: Computes aggregate slab DL/LL per column using equivalent full floors (and live-load reduction when enabled), plus column self-weight; stores service and factored totals.

4) Data and UI
- `table_builders` now persists one element per column, per-column concrete, tributary rectangle measures, and aggregate loads.
- The app’s Geometry tab includes a “Columns” section listing all columns and showing a detail panel with costs and (aggregate) loads for a selected column.

### Why these changes

- Correctness: We need columns that span drive aisles, support ramp centerlines, and never obstruct stalls. The legacy uniform grid could both under- and over-count columns and didn’t align with parking geometry.
- Atomization: Per-column geometry and loads are required for per-column costs, slab punching checks, and auditability.
- Stability: The midpoint method yields predictable tributary boundaries that adjust automatically with geometry changes and ensure ≤ 31' spans.
- Composability: One authoritative generator feeds visualization, loads, footings, and costing; fewer bespoke paths reduce drift and bugs.

### Assumptions (Phase A – to be relaxed in Phase B/C)

- Core shapes are approximated as axis-aligned rectangles; the calculator subtracts overlaps per rectangle. The NE L-shape is decomposed into simple rectangles for now.
- Entry opening subtraction is applied at the west-perimeter line and only affects aggregate areas (not yet per-level).
- Load distribution uses plan area (DL/LL per SF); slab slope and local stiffness effects are not modeled for gravity allocations (acceptable for preliminary sizing).
- Live-load reduction uses floors-supported ≈ equivalent full floors (total_gsf/footprint_sf). We will replace this with exact floors-supported per column in the per-level mapping phase.
- Split-level per-level activation is not yet applied (aggregate-only). Phase B will compute which sections are active at each discrete level and assign per-level areas accordingly.

### Validation and diagnostics (now and next)

Now:
- Sanity checks in UI: columns, volumes, and nearest footing costs.
- Defensive tolerances in midpoint/overlap math.
- Minimal diagnostics bundle returned via pipeline:
  - Components:
    - Columns: `total_count`, `per_level[{level_name, count}]`
    - Floors: `total_levels`, `levels[{level_name, gsf, slab_type, elevation_ft}]`
    - Cores: `num_stairs`, `num_stair_flights`, `num_elevator_stops`
    - Retaining walls: `perimeter_lf`, `area_sf_by_level[{level_name, area_sf}]`, `total_area_sf`, `tracked_total_area_sf`
    - Rebar: `sog_sf`, `suspended_slab_sf`, `sog_rebar_rate_lbs_per_sf`, `suspended_rebar_rate_lbs_per_sf`, `sog_rebar_lbs`, `suspended_slab_rebar_lbs`, `total_slabs_rebar_lbs`, `total_footing_rebar_lbs`, `total_rebar_lbs_all`
  - Imposed load reconciliation (slab-only at level granularity):
    - Modeled totals (DL/LL/Total) vs expected totals:
      - DL_expected = `total_gsf × dead_load_psf`
      - LL_expected = `suspended_gsf × live_load_psf × (0.8 if (allow_ll_reduction and suspended_levels ≥ 2) else 1.0)`
    - Deltas (%): `((modeled/expected) − 1) × 100`
    - Tolerance: `±3.0%` (default)
    - Pass flags: `passes.{dl,ll,total,all}`

Next:
- Per-level area conservation: sum of per-column level areas should match level GSF (±1–2%). Emit diagnostics if out-of-bounds.
- Symmetry checks in symmetric layouts (optional diagnostics).

### Effects on related systems

- Footing design benefits immediately from better tributary areas per column.
- Visualization uses the authoritative `garage.columns`, so 3D and 2D display the new grid without extra glue code.
- Costing remains compatible; in a later step we will attribute stud-rail costs per column based on slab punching at suspended levels.

### Next-phase plan (Is per-level mapping necessary?)

Short answer: Yes—per-level coverage mapping is necessary for accuracy and transparency:
- Split-level geometry activates different parking zones per half-level; aggregate areas can’t capture which columns are actually engaged at each level.
- Floors-supported for ASCE-7 reduction depends on actual levels carried by each column; equivalent floors is a good first approximation but over/underestimates edge and ramp-center columns.
- Slab punching checks are per suspended level at each column; we need per-level areas/loads to compute demand and assess stud-rail requirements accurately.
- Entry/top reductions, turn zones, and ramp termination affect different levels; per-level mapping isolates these effects.

What we’ll build (Phase B):
1) Per-level activation:
   - Split-level: for each level index, determine the active turn zone (N/S), ramp side (W/E), and which sections contribute (perimeter row on active side, adjacent center row), including entry and top reductions.
   - Single-ramp: all perimeter/center rows with the ramp bay active; include top termination reductions.
2) Per-level coverage per column:
   - For each Y-line and level, compute coverage length in X after blockages.
   - Column level area = coverage length ∩ column’s X-interval × column’s Y-width (clip overlap).
3) Loads per level per column:
   - DL/LL per level from area-level × psf; sum to service/factored per column.
   - Floors-supported per column = count of levels with suspended area > 0; re-apply live-load reduction accordingly.
4) Validation:
   - Sum column areas per level ≈ level GSF; flag mismatches.
5) Storage and UI:
   - Persist per-level areas and loads; expose per-level breakdown in the column inspector.

Following Phase B (Phase C):
- Slab punching per suspended level at each column (ACI 318), stud-rail requirements and per-column cost attribution.
- Finalize per-column ASCE-7 reduction using exact floors-supported.
- Single-ramp parity in per-level mapping and punching checks.

### Deprecations and removals

- Legacy uniform grid column loops were removed; all downstream code consumes `garage.columns`.
- Contradictory comments indicating “no center columns” have been replaced; center ramp columns are now explicitly supported.

## Progress update: Per-level mapping, validation, punching, and UI metrics

- Implemented split-level per-level coverage mapping:
  - Active zones per level (turn zone, ramp-side perimeter, adjacent center row) with entry/top adjustments.
  - Per-column per-level areas computed from union of section coverage intervals intersected with the column’s X/Y tributaries.
- Loads and ASCE 7 reduction:
  - Floors-supported per column derived from suspended-level coverage; live-load reduction applied at per-level granularity.
- Slab punching checks:
  - Added punching capacity vs per-level factored reactions for suspended levels; flagged joints requiring stud rails.
  - Cost engine now attributes stud rails per required joint (fallback: per-column if unavailable).
- Validation:
  - Per-level area conservation logged to diagnostics with variance% and severity; UI shows Max variance and count within ±2%.
- UI metrics:
  - New summary metrics: Stud Rail Joints Required, Max Level Area Variance (%), Levels within 2%.
  - Column inspector shows per-level areas/loads and punching utilization, with stud-rail requirement indicators.
- Out of scope in this update:
  - Single-ramp per-level mapping (will follow the same engine, deferred per request).


